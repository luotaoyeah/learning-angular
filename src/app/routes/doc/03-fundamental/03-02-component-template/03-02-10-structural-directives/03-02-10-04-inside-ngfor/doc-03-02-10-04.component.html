<p-accordionTab header="Inside NgFor" [transitionOptions]="'0ms'">
  <p>
    *ngFor 跟 *ngIf 类似, 也是语法糖, *ngFor 后面的 expression 称之为
    microsyntax, 最终会被 angular 编译为 ng-template 元素上的一系列属性
  </p>
  <p>
    使用 let 关键字声明的东西称之为 template input variable, 比如下面的: let
    hero, let i, let o 声明了三个 input variable, 它们最终会被编译为
    <code>&lt;ng-template&gt;</code> 上面的 property binding, 形式为: let-hero,
    let-i, let-o
  </p>
  <p>
    of 和 trackById 会被编译为 ngForOf 和 ngForTrackBy, 自动加上了 ngFor 前缀,
    它们其实就是 NgForOf 指令的两个 input property
  </p>
  <p>
    每次迭代的时候, ngFor 会设置它的 context 对象的属性, 这些属性包括: index,
    odd, $implicit, 其中 $implicit 的值会被赋值给 hero 这个 template input
    variable, 而 index 和 odd 会分别赋值给 i 和 o 这两个 input variables
  </p>
  <ul>
    <li
      *ngFor="
        let hero of heroes;
        let i = index;
        let o = odd;
        trackBy: trackById
      "
      [class.odd]="o"
    >
      [{{ i }} ].{{ hero.name }}
    </li>
  </ul>
  <ul>
    <ng-template
      ngFor
      let-hero
      let-i="index"
      let-o="odd"
      [ngForOf]="heroes"
      [ngForTrackBy]="trackById"
    >
      <li [class.odd]="o">[{{ i }}].{{ hero.name }}</li>
    </ng-template>
  </ul>

  <hr />
  <p>
    template input variable 和 template reference variable 是不一样的, 比如在
    NgForOf 中的 input variable 只对本次迭代有效, 而 reference variable
    在当前整个 template 中都有效, 它表示的是对它所在的宿主元素的实例引用
  </p>

  <hr />
  <p>一个宿主元素上, 最多只能使用一个 structural directive</p>
</p-accordionTab>
