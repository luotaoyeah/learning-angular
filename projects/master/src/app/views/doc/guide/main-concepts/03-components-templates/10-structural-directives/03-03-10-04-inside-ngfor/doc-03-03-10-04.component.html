<p>
  <code>*ngFor</code> 跟 <code>*ngIf</code> 类似, 前面的 * 也是语法糖, <code>*ngFor</code> 后面的 expression 称之为
  microsyntax, 最终会被 angular 编译为 <code>&lt;ng-template&gt;</code> 元素上的一系列属性
</p>
<p>
  使用 <code>let</code> 关键字声明的东西称之为 template input variable, 比如 <code>let hero</code>, <code>let i</code>,
  <code>let o</code> 声明了三个 input variables, 它们最终会被编译为 <code>&lt;ng-template&gt;</code> 上面的 property
  binding, 形式为: <code>let-hero</code>, <code>let-i</code>, <code>let-o</code>
</p>
<p>
  <code>of</code> 和 <code>trackBy</code> 会被编译为 <code>ngForOf</code> 和 <code>ngForTrackBy</code>, 它们其实就是
  <code>NgForOf</code> 指令的两个 input property
</p>
<p>
  每次迭代的时候, <code>ngFor</code> 会设置它的 context 对象的属性, 这些属性包括: <code>index</code>, <code>odd</code>,
  <code>$implicit</code>, 其中 <code>$implicit</code> 的值会被赋值给 <code>let-hero</code> 中的 template input variable,
  而 <code>index</code> 和 <code>odd</code> 会分别赋值给 <code>i</code> 和 <code>o</code> 这两个 input variables
</p>
<ul>
  <li *ngFor="let hero of heroes; let i = index; let o = odd; trackBy: trackById" [class.odd]="o">
    [{{ i }} ].{{ hero.name }}
  </li>
</ul>
<ul>
  <ng-template ngFor let-hero let-i="index" let-o="odd" [ngForOf]="heroes" [ngForTrackBy]="trackById">
    <li [class.odd]="o">[{{ i }}].{{ hero.name }}</li>
  </ng-template>
</ul>

<nz-divider [nzDashed]="true"></nz-divider>

<p>
  template input variable 和 template reference variable 是不一样的, 比如在
  <code>NgForOf</code> 中的 input variable 只对本次迭代有效, 而 reference variable 在当前整个 template 中都有效,
  它表示的是对它所在的宿主元素的实例引用
</p>

<nz-divider [nzDashed]="true"></nz-divider>

<p>一个宿主元素上, 最多只能使用一个 structural directive</p>
